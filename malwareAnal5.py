#naive bayes multinomial whit dinstance function
import string
import os
import csv 

#in questa versione ho provato a inserire una funzione di distanza tra le stringhe ma il tempo per eseguirlo  troppo elevato
def lev(s1, s2):
    if len(s1) < len(s2):
        return lev(s2, s1)

    # len(s1) >= len(s2)
    if len(s2) == 0:
        return len(s1)

    previous_row = range(len(s2) + 1)
    for i, c1 in enumerate(s1):
        current_row = [i + 1]
        for j, c2 in enumerate(s2):
            insertions = previous_row[j + 1] + 1 # j+1 instead of j since previous_row and current_row are one character longer
            deletions = current_row[j] + 1       # than s2
            substitutions = previous_row[j] + (c1 != c2)
            current_row.append(min(insertions, deletions, substitutions))
        previous_row = current_row
    
    return previous_row[-1]
	
#open file csv with all malware, save these in a string
with open("C:\Users\Lorenzo\Desktop\drebin\sha256_family.csv", "rb") as csvfile:
	spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')
	in_line=""
	for row in spamreader:
		in_line=in_line+ ","+''.join(row)

#open directory where there are the training set files save all the file inside in a list and create a dictionary from this list		
direct= "C:\Users\Lorenzo\Desktop\MachineLearning\datasetMalware10\\"
listM = os.listdir('C:\Users\Lorenzo\Desktop\MachineLearning\datasetMalware10')
dictM=dict.fromkeys(listM) 

#open directory where there are the tester set files save all the file inside in a list and create a dictionary from this list	
directTest= "C:\Users\Lorenzo\Desktop\MachineLearning\datasetMalware11\\"
listTest = os.listdir('C:\Users\Lorenzo\Desktop\MachineLearning\datasetMalware11')
dictTest=dict.fromkeys(listTest)

momstr = ""
i=0
j=0
dictMalFeat={}
dictNonFeat={}

#now for all the malwere saved in svc file say if they are inside or not of the two directory and labeled each malwere with "M"
for indexj in range(0,len(in_line)):
		if in_line[indexj].isalnum():
			g=in_line[indexj]
			momstr=momstr+g
		else:
			if not(momstr==""):
				if dictM.has_key(momstr):
					dict2={momstr: "M"}
					dictM.update(dict2)
					i=i+1
				if dictTest.has_key(momstr):
					dict4={momstr: "M"}
					dictTest.update(dict4)
					j=j+1
				momstr=""
				
print "\nLEARNING PHASE CONCLUSED, FOUNDED ",i, " DANGEROUS FILE ON ",
print len(dictM), "FILE ESAMINATED IN TRAINING SET"
print "\nFOUNDED ",j, " DANGEROUS FILE ON ",
print len(dictTest), "FILE ESAMINATED IN TEST SET\n"

#calculate the probability that one file is malware or not
probMal=float(i)/len(dictM)
probNon= 1-float(probMal)
print "PROBABILITY THAT ONE FILE IS MALWARE: ", probMal
print "INSTEAD THE PROBABILITY THAT IT ISN'T: ", probNon	
	
#now create two dictionary where write the features of the file inside training set, divided in malware and not, and counting the number of recurrences
for indexj in range(0,len(listM)):
	fileName=listM[indexj]
	fileNameTot=direct+fileName
	in_file=open(fileNameTot, "r")

	if dictM.get(fileName)=="M":
		while True:
			in_line1=in_file.readline()
			if in_line1=="":
				break
			else:
				if dictMalFeat.has_key(in_line1):
					c=dictMalFeat.get(in_line1)
					dict3={in_line1: c+1}
					dictMalFeat.update(dict3)
				else:
					dict3={in_line1: 1}
					dictMalFeat.update(dict3)
	else:
		while True:
			in_line1=in_file.readline()
			if in_line1=="":
				break
			else:
				if dictNonFeat.has_key(in_line1):
					c=dictNonFeat.get(in_line1)
					dict3={in_line1: c+1}
					dictNonFeat.update(dict3)
				else:
					dict3={in_line1: 1}
					dictNonFeat.update(dict3)

print "\nTHE TOTAL FEATURES OF MALWARES ARE ",len(dictMalFeat), " WHILE THESE THAT ARE NOT:",len(dictNonFeat)
v= len(dictMalFeat)+len(dictNonFeat)

truePos=0
falsePos=0
trueNeg=0
falseNeg=0
#factor that rappresent the distance between the words
alpha=0


#opening the tester set and for each file calculate the probability that it is malware or not, so counting number of false/true Positive/Negative
for indexj in range(0,len(listTest)):
	print indexj
	fileName=listTest[indexj]
	fileNameTot=directTest+fileName
	in_file=open(fileNameTot, "r")
	proConMal=1
	proConNon=1
	
	if dictTest.get(fileName)=="M":
		while True:

			in_line1=in_file.readline()
			if in_line1=="":
				break
			else:
				for x in dictMalFeat.keys():
					#print x
					dist=lev(x,in_line1)
					if (dist<5):
						alpha=1
					elif (dist<10):
						alpha=float(0.75)
					elif (dist<15):
						alpha=float(0.5)
					elif (dist<20):
						alpha=float(0.25)
					else:
						alpha=0
					c=float(alpha)*dictMalFeat.get(x)
					k =float(c+1)/float(c+v)
					proConMal=proConMal*float(k)
				for x in dictNonFeat.keys():
					#print x
					dist=lev(x,in_line1)
					if (dist<5):
						alpha=1
					elif (dist<10):
						alpha=float(0.75)
					elif (dist<15):
						alpha=float(0.5)
					elif (dist<20):
						alpha=float(0.25)
					else:
						alpha=0
					c=float(alpha)*dictNonFeat.get(x)
					k =float(c+1)/float(c+v)
					proConNon=proConNon*float(k)
		vnbMal=proConMal*float(probMal)
		vnbNon=proConNon*float(probNon)
		if(vnbMal>=vnbNon):truePos=truePos+1
		print "TP:",truePos
		if(vnbMal<vnbNon):falseNeg=falseNeg+1

	else:
		while True:
			in_line1=in_file.readline()
			#print in_line1
			if in_line1=="":
				break
			else:
				for x in dictMalFeat.keys():
					#print x
					dist=lev(x,in_line1)
					if (dist<=5):
						alpha=1
					elif (dist<=10):
						alpha=float(0.75)
					elif (dist<=15):
						alpha=float(0.5)
					elif (dist<=20):
						alpha=float(0.25)
					else:
						alpha=0
					c=float(alpha)*dictMalFeat.get(x)
					k =float(c+1)/float(c+v)
					proConMal=proConMal*float(k)
				for x in dictNonFeat.keys():
					#print x
					dist=lev(x,in_line1)
					if (dist<5):
						alpha=1
					elif (dist<10):
						alpha=float(0.75)
					elif (dist<15):
						alpha=float(0.5)
					elif (dist<20):
						alpha=float(0.25)
					else:
						alpha=0
					c=float(alpha)*dictNonFeat.get(x)
					k =float(c+1)/float(c+v)
					proConNon=proConNon*float(k)
		vnbMal=proConMal*float(probMal)
		vnbNon=proConNon*float(probNon)
		if(vnbMal>=vnbNon):falsePos=falsePos+1
		if(vnbMal<vnbNon):trueNeg=trueNeg+1
		print "TN:",trueNeg
	

print "\nIN TESTER WE FOUND ",truePos," TRUE POSITIVES INSTEAD OF ",j
print "THE NUMBER OF TRUE NEGATIVE:",trueNeg,"INSTEAD OF ",len(dictTest)-j
print "\nFALSE POSITIVES: ",falsePos,"\nFALSE NEGATIVE: ",falseNeg

#calculate the Evaluetion Metrics
precision= float(truePos)/(truePos+falsePos)
print "\nPRECISION:",precision
recall=float(truePos)/(truePos+falseNeg)
print "RECALL:",recall
falsePosRate=float(falsePos)/(falsePos+trueNeg)
print "FALSE POSITIVE RATE:",falsePosRate
accuracy=float(trueNeg+truePos)/(trueNeg+truePos+falseNeg+falsePos)
print "ACCURACY:",accuracy
fMeasure=2*(float(precision)*float(recall))/(float(precision)+float(recall))
print "F-MEASURE:",fMeasure





			
			
	
					


