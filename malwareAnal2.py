#naiveBayesMultinomial
import string
import os
import csv 

#open a txt file to write directly the results obteined
f=open("C:\Users\Lorenzo\Desktop\lollo.txt","a+")
f.write("\n_________________________________________________________")

#open file csv with all malware, save these in a string
with open("C:\Users\Lorenzo\Desktop\drebin\sha256_family.csv", "rb") as csvfile:
	spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')
	in_line=""
	for row in spamreader:
		in_line=in_line+ ","+''.join(row)

#open directory where there are the training set files save all the file inside in a list and create a dictionary from this list		
direct= "C:\Users\Lorenzo\Desktop\MachineLearning\datasetMalware\\"
listM = os.listdir('C:\Users\Lorenzo\Desktop\MachineLearning\datasetMalware')
dictM=dict.fromkeys(listM) 

#open directory where there are the tester set files save all the file inside in a list and create a dictionary from this list	
directTest= "C:\Users\Lorenzo\Desktop\MachineLearning\datasetMalware2\\"
listTest = os.listdir('C:\Users\Lorenzo\Desktop\MachineLearning\datasetMalware2')
dictTest=dict.fromkeys(listTest)

momstr = ""
i=0
j=0
dictMalFeat={}
dictNonFeat={}

#now for all the malwere saved in svc file say if they are inside or not of the two directory and labeled each malwere with "M"
for indexj in range(0,len(in_line)):
		if in_line[indexj].isalnum():
			g=in_line[indexj]
			momstr=momstr+g
		else:
			if not(momstr==""):
				if dictM.has_key(momstr):
					dict2={momstr: "M"}
					dictM.update(dict2)
					i=i+1
				if dictTest.has_key(momstr):
					dict4={momstr: "M"}
					dictTest.update(dict4)
					j=j+1
				momstr=""
				
print "\nLEARNING PHASE CONCLUSED, FOUNDED ",i, " DANGEROUS FILE ON ",
print len(dictM), "FILE ESAMINATED IN TRAINING SET"
print "\nFOUNDED ",j, " DANGEROUS FILE ON ",
print len(dictTest), "FILE ESAMINATED IN TEST SET\n"

f.write("\nLEARNING PHASE CONCLUSED, FOUNDED "+str(i)+ " DANGEROUS FILE ON ")
f.write(str(len(dictM))+ " FILE ESAMINATED IN TRAINING SET")
f.write("\nFOUNDED "+str(j)+ " DANGEROUS FILE ON ",)
f.write(str(len(dictTest))+ " FILE ESAMINATED IN TEST SET\n")
f.write("\nTOTAL NUMBER OF FILE: "+str(len(dictM)+len(dictTest)))


#calculate the probability that one file is malware or not
probMal=float(i)/len(dictM)
probNon= 1-float(probMal)
print "PROBABILITY THAT ONE FILE IS MALWARE: ", probMal
print "INSTEAD THE PROBABILITY THAT IT ISN'T: ", probNon	

f.write("\nPROBABILITY THAT ONE FILE IS MALWARE: "+str(probMal))
f.write("\nINSTEAD THE PROBABILITY THAT IT ISN'T: "+str( probNon))
	
#now create two dictionary where write the features of the file inside training set, divided in malware and not, and counting the number of recurrences
for indexj in range(0,len(listM)):
	fileName=listM[indexj]
	fileNameTot=direct+fileName
	in_file=open(fileNameTot, "r")

	if dictM.get(fileName)=="M":
		while True:
			in_line1=in_file.readline()
			if in_line1=="":
				break
			else:
				if dictMalFeat.has_key(in_line1):
					c=dictMalFeat.get(in_line1)
					dict3={in_line1: c+1}
					dictMalFeat.update(dict3)
				else:
					dict3={in_line1: 1}
					dictMalFeat.update(dict3)
	else:
		while True:
			in_line1=in_file.readline()
			if in_line1=="":
				break
			else:
				if dictNonFeat.has_key(in_line1):
					c=dictNonFeat.get(in_line1)
					dict3={in_line1: c+1}
					dictNonFeat.update(dict3)
				else:
					dict3={in_line1: 1}
					dictNonFeat.update(dict3)

print "\nTHE TOTAL FEATURES OF MALWARES ARE ",len(dictMalFeat), " WHILE THESE THAT ARE NOT:",len(dictNonFeat)
f.write("\nTHE TOTAL FEATURES OF MALWARES ARE "+str(len(dictMalFeat))+ " WHILE THESE THAT ARE NOT:"+str(len(dictNonFeat)))
v= len(dictMalFeat)+len(dictNonFeat)

truePos=0
falsePos=0
trueNeg=0
falseNeg=0

#opening the tester set and for each file calculate the probability that it is malware or not, so counting number of false/true Positive/Negative
for indexj in range(0,len(listTest)):
	fileName=listTest[indexj]
	fileNameTot=directTest+fileName
	in_file=open(fileNameTot, "r")
	proConMal=1
	proConNon=1
	
	if dictTest.get(fileName)=="M":
		while True:
			in_line1=in_file.readline()
			if in_line1=="":
				break
			else:
				if dictMalFeat.has_key(in_line1):
					c=dictMalFeat.get(in_line1)
					k =float(c+1)/float(c+v)
					proConMal=proConMal*float(k)
				if dictNonFeat.has_key(in_line1):
					c=dictNonFeat.get(in_line1)
					k =float(c+1)/float(c+v)
					proConNon=proConNon*float(k)
		vnbMal=proConMal*float(probMal)
		vnbNon=proConNon*float(probNon)
		if(vnbMal>=vnbNon):truePos=truePos+1
		if(vnbMal<vnbNon):falseNeg=falseNeg+1

	else:
		while True:
			in_line1=in_file.readline()
			if in_line1=="":
				break
			else:
				if dictMalFeat.has_key(in_line1):
					c=dictMalFeat.get(in_line1)
					k =float(c+1)/float(c+v)
					proConMal=proConMal*float(k)
				if dictNonFeat.has_key(in_line1):
					c=dictNonFeat.get(in_line1)
					k =float(c+1)/float(c+v)
					proConNon=proConNon*float(k)
		vnbMal=proConMal*float(probMal)
		vnbNon=proConNon*float(probNon)
		if(vnbMal>=vnbNon):falsePos=falsePos+1
		if(vnbMal<vnbNon):trueNeg=trueNeg+1

print "\nIN TESTER WE FOUND ",truePos," TRUE POSITIVES INSTEAD OF ",j
print "THE NUMBER OF TRUE NEGATIVE:",trueNeg,"INSTEAD OF ",len(dictTest)-j
print "\nFALSE POSITIVES: ",falsePos,"\nFALSE NEGATIVE: ",falseNeg

f.write("\nIN TESTER WE FOUND "+str(truePos)+" TRUE POSITIVES INSTEAD OF "+str(j))
f.write("\nTHE NUMBER OF TRUE NEGATIVE:"+str(trueNeg)+" INSTEAD OF "+str(len(dictTest)-j))
f.write("\nFALSE POSITIVES: "+str(falsePos)+"\nFALSE NEGATIVE: "+str(falseNeg))

#calculate the Evaluetion Metrics
precision= float(truePos)/(truePos+falsePos)
print "\nPRECISION:",precision
f.write("\nPRECISION:"+str(precision))
recall=float(truePos)/(truePos+falseNeg)
print "RECALL:",recall
f.write("\nRECALL:"+str(recall))
falsePosRate=float(falsePos)/(falsePos+trueNeg)
print "FALSE POSITIVE RATE:",falsePosRate
f.write("\nFALSE POSITIVE RATE:"+str(falsePosRate))
accuracy=float(trueNeg+truePos)/(trueNeg+truePos+falseNeg+falsePos)
print "ACCURACY:",accuracy
f.write("\nACCURACY:"+str(accuracy))
if precision!=0 or recall!=0:
	fMeasure=2*(float(precision)*float(recall))/(float(precision)+float(recall))
	print "F-MEASURE:",fMeasure
	f.write("\nF-MEASURE:"+str(fMeasure))
else:
	print "TO LOW PRECISION AND RECALL TO CALCULATE F-MEASURE"
	f.write("\nTO LOW PRECISION AND RECALL TO CALCULATE F-MEASURE\n")

f.close()



			
			
	
					


